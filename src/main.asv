%{
Test Functions for rn. 
    power_flow_f looks good. 
    
rn this is scrap to see if I can start figuring this out.
%}

%{
hold on 
axis([-.5 1.5 -4 4])
plot([-.5 1.5], [0 0]);
fplot(@(n_l) power_flow_f(10,4,n_l), [0,1]);
hold off
%}
import const.*
%Declare Paramiteres as needed
testCase = 'case9';
H = 7; %Inertia Constant H
%Load Test
network = loadcase(testCase);
%Find number of lines
n_g     = uint8(size(network.gen, 1));     % # of generators
n       = uint8(size(network.bus, 1));     % # of Nodes
n_l     = uint8(size(network.branch, 1));  % # of lines
nodes   = [n_g n_l n];
w_0 = idxVal.w_oa; %Nominal Frequency
%Calculate inital conditions for w_i
w_i = zeros(1, n_g);
w_i(:) = w_0;
P = zeros(n);
for i = 1:n
 P(i) = network.bus(i,idxVal.Real_Power);
end
%Calcultate the value of M_i
M_i = zeros( 1, n_g );
for i=1:n_g 
    p_0 = network.gen(i,idxVal.mBase);  %Base Power
    M_i(i) = (w_0/p_0)*H; %Calculate M_i
end
B_ij = zeros(n,n);
for i = 1:n
    x = network.branch(i,idxVal.X_ij);
    mi = network.branch(i,idxVal.fromBus);
    mj = network.branch(i,idxVal.toBus);
    B_ij(mi,mj) = -1/x;
end
W_ij = zeros(n,n);
for i = 1:n
    x = network.branch(i,idxVal.X_ij);
    mi = network.branch(i,idxVal.fromBus);
    mj = network.branch(i,idxVal.toBus);
    W_ij(mi,mj) = 1.1.*network.branch(i,idxVal.MVA_Branch);
end
%Make J matrix
j11 = zeros(n_g,n_g);
for i =1:n_g
j11(i,i) = -M_i(i)./(5).^2; %'5' here is the Damping D, will ned to find. 
%this is what they chose.
end
j33 = zeros(n,n);
for i =1:n
j33(i,i) = -1; %'1' here is the load frequency ratio, will ned to find.
%this is what they chose.
end
j44 = zeros(n_l,n_l);
for i = 1:n_l
j44(i,i)= -1./(1.1.*network.branch(i,idxVal.MVA_Branch));
end
j12 = zeros(n_g,n_g);
j12(1,:)=(1/M_i(1));
for i = 2:n_g
j12(i+1,i)=-(1/M_i(i));
end
j13 = zeros(n_g, n_g);
j13(1,:) = 1./M_i(1);
J = {j11,  j12,  j13,   0;
    -j12.',  0,    0,   0; 
    -j13.',  0, -j33,   0;
         0,  0,    0, j44
         };
delta_current = randn(n,1)./10;
omega_current = randn(n,1)./10;
delta_current(1) = 0;
neu_current   = ones(1,n)*.95;
syms omega(t) delta(t) neu(t)
j=1;
for i = 1:n
    for j = 1:n    
        temp = temp + B_ij(i,j).*sin(delta_current(j) - delta_current(i));        
    end
omega_dot = -omega_current(i) -(1/5)*( P(i) +  temp);

omega_current(i) = omega_dot.*0
end
     
     
     
     
     
     
     
     
     
     
     